package mavlink

import (
    "fmt"
)

// Packet is a wire type for encoding/decoding mavlink messages.
// use the ToPacket() and FromPacket() routines on specific message
// types to convert them to/from the Message type.
type packet{{.MavlinkVersion}} struct {
{{- if eq .MavlinkVersion 2}}
	incompatFlags uint8     // incompat flags
	compatFlags   uint8     // compat flags
{{- end}}
	seqID         uint8     // Sequence of packet
	sysID         uint8     // ID of message sender system/aircraft
	compID        uint8     // ID of the message sender component
	msgID         MessageID // ID of message in payload
	payload       []byte
	checksum      uint16
}

// SysID returns system id
func (p *packet{{.MavlinkVersion}}) SysID() uint8 {
    return p.sysID
}

// CompID returns component id
func (p *packet{{.MavlinkVersion}}) CompID() uint8 {
    return p.compID
}

// MsgID returns message id
func (p *packet{{.MavlinkVersion}}) MsgID() MessageID {
    return p.msgID
}

// Checksum returns packet checksum
func (p *packet{{.MavlinkVersion}}) Checksum() uint16 {
    return p.checksum
}

// SeqID returns packet sequence number
func (p *packet{{.MavlinkVersion}}) SeqID() uint8 {
    return p.seqID
}

// Payload returns packet payload
func (p *packet{{.MavlinkVersion}}) Payload() []byte {
    // todo: maybe COPY???
    return p.payload
}

// Assign assign internal fields from right hand side packet
func (p *packet{{.MavlinkVersion}}) Assign(rhs Packet) error {
    packet, ok := rhs.(*packet{{.MavlinkVersion}})
    if !ok {
        return fmt.Errorf("cast interface '%+v' to '*packet{{.MavlinkVersion}}' fail", rhs)
    }
{{- if eq .MavlinkVersion 2}}
    packet.incompatFlags = p.incompatFlags
    packet.compatFlags = p.compatFlags
{{- end}}
    packet.seqID = p.seqID
    packet.sysID = p.sysID
    packet.compID = p.compID
    packet.msgID = p.msgID
    packet.checksum = p.checksum
    packet.payload = append(packet.payload[:0], p.payload...)
    return nil
}


func (p *packet{{.MavlinkVersion}}) nextSeqNum() byte {
	currentSeqNum++
	return currentSeqNum
}

// Encode trying to encode message to packet
func (p *packet{{.MavlinkVersion}}) encode(sysID, compID uint8, m Message) error {
	p.seqID = p.nextSeqNum()
	p.sysID = sysID
	p.compID = compID
	return p.Encode(m)
}

// Encode trying to encode message to packet
func (p *packet{{.MavlinkVersion}}) Encode(m Message) error {
	if err := m.Pack(p); err != nil {
		return err
	}
{{- if eq .MavlinkVersion 2 }}
	payloadLen := len(p.payload)
	for payloadLen > 1 && p.payload[payloadLen-1] == 0 {
		payloadLen--
	}
	p.payload = p.payload[:payloadLen]
{{- end }}
	if err := p.fixChecksum(); err != nil {
		return err
	}
	return nil
}

// Decode trying to decode message to packet
func (p *packet{{.MavlinkVersion}}) Decode(m Message) error {
{{- if eq .MavlinkVersion 2 }}
    if msg, ok := supported[p.msgID]; !ok {
        return ErrUnknownMsgID
    } else if len(p.payload) < msg.Size {
		p.payload = append(p.payload, zeroTail[:msg.Size-len(p.payload)]...)
	}
{{- end }}
    return m.Unpack(p)
}

// Unmarshal trying to de-serialize byte slice to packet
func unmarshal{{.MavlinkVersion}}(buffer []byte, p *packet{{.MavlinkVersion}}) error {
	parser := _parsersPool_v{{.MavlinkVersion}}.Get().(*parser{{.MavlinkVersion}})
	defer parser.Destroy()
	for _, c := range buffer {
		packet, err := parser.ParseChar(c)
		if err != nil {
			return err
		}
		if packet != nil {
			return p.Assign(packet)
		}
	}
	return ErrNoNewData
}

// Marshal trying to serialize byte slice from packet
func marshal{{.MavlinkVersion}}(p *packet{{.MavlinkVersion}}) ([]byte, error) {
	if p == nil {
		return nil, ErrNilPointerReference
	}
    bytes := make([]byte, 0, {{if eq .MavlinkVersion 2 -}} 12 {{- else -}} 8 {{- end}}+len(p.payload))
    // header
    bytes = append(bytes,
	    {{if eq .MavlinkVersion 2 -}} 0xfd {{- else -}} 0xfe {{- end}},
	    byte(len(p.payload)),
{{- if eq .MavlinkVersion 2}}
	    uint8(p.incompatFlags),
	    uint8(p.compatFlags),
{{- end}}
	    p.seqID,
	    p.sysID,
	    p.compID,
	    uint8(p.msgID),
{{- if eq .MavlinkVersion 2}}
	    uint8(p.msgID >> 8),
	    uint8(p.msgID >> 16),
{{- end}}
    )
    // payload
	bytes = append(bytes, p.payload...)
	// crc
	bytes = append(bytes, p.u16ToBytes(p.checksum)...)
	return bytes, nil
}

func (p *packet{{.MavlinkVersion}}) fixChecksum() error {
    msg, ok := supported[p.msgID]
    if !ok {
		return ErrUnknownMsgID
    }
	crc := NewX25()
	crc.WriteByte(byte(len(p.payload)))
{{- if eq .MavlinkVersion 2}}
	crc.WriteByte(p.incompatFlags)
	crc.WriteByte(p.compatFlags)
{{- end}}
	crc.WriteByte(p.seqID)
	crc.WriteByte(p.sysID)
	crc.WriteByte(p.compID)
	crc.WriteByte(byte(p.msgID >> 0 ))
{{- if eq .MavlinkVersion 2}}
	crc.WriteByte(byte(p.msgID >> 8 ))
	crc.WriteByte(byte(p.msgID >> 16))
{{- end}}
	crc.Write(p.payload)
	crc.WriteByte(msg.Extra)
	p.checksum = crc.Sum16()
	return nil
}

func (p *packet{{.MavlinkVersion}}) u16ToBytes(v uint16) []byte {
	return []byte{byte(v & 0xff), byte(v >> 8)}
}

// Message function produce message from packet
func (p *packet{{.MavlinkVersion}}) Message() (Message, error) {
    msg, ok := supported[p.msgID]
	if !ok {
		return nil, ErrUnknownMsgID
	}
	return msg.Constructor(p), nil
}

// String function return string view of Packet struct
func (p *packet{{.MavlinkVersion}}) String() string {
	return fmt.Sprintf(
		"&packet{{.MavlinkVersion}}{ {{ if eq .MavlinkVersion 2 }}incompatFlags: %08b, compatFlags: %08b, {{ end }}seqID: %d, sysID: %d, compID: %d, msgID: %d, payload: %s, checksum: %d }",
{{- if eq .MavlinkVersion 2}}
    	p.incompatFlags,
	    p.compatFlags,
{{- end}}
		p.seqID,
		p.sysID,
		p.compID,
		int64(p.msgID),
		func() string {
			msg, err := p.Message()
			if err != nil {
				return fmt.Sprintf("%0X", p.payload)
			}
			return msg.String()
		}(),
		p.checksum,
	)
}
