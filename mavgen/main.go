package main

//go:generate templify message.template
//go:generate templify dialect.template

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
)

const (
	generatedHeader = "// Code generated by go-mavlink/mavgen\n// DO NOT EDIT!\n\n"
)

var (
	Version        = "devel"
	infile         = flag.String("f", "", "mavlink xml-definition file input")
	outfile        = flag.String("o", "", "output file name")
	packetmode     = flag.Bool("p", false, "packet mode. if set mavgen will be create nessesary go-sources")
	version        = flag.String("v", Version, "version of mavlink dialect, usage with -p flag.")
	mavlinkVersion = flag.Int("m", 2, "version of mavlink protocol, usage with -p flag.")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("mavgen: ")
	flag.Parse()

	fmt.Printf("go-mavgen version %s\n\n", Version)

	fin, err := os.Open(*infile)
	if err != nil {
		log.Fatal("couldn't open input: ", err)
	}
	defer fin.Close()

	d, err := ParseDialect(fin, baseName(*infile))
	if err != nil {
		log.Fatal("parse fail: ", err)
	}

	dialectFileName := findOutFile()

	dialectFile, err := os.Create(dialectFileName)
	if err != nil {
		log.Fatal("couldn't open output: ", err)
	}
	defer dialectFile.Close()

	if err := d.GenerateGo(dialectFile); err != nil {
		log.Fatal("couldn't write to output: ", err)
	}
	if *packetmode {
		dialectDir := filepath.Dir(dialectFileName) + string(filepath.Separator)
		dialectName := "Dialect" + strcase.ToCamel(d.Name)

		data := struct {
			Mavlink2    bool
			Mavlink1    bool
			DialectName string
		}{
			Mavlink2:    *mavlinkVersion&(1<<1) > 0,
			Mavlink1:    *mavlinkVersion&(1<<0) > 0,
			DialectName: dialectName,
		}

		t, err := template.New("message").Parse(messageTemplate())

		if err != nil {
			log.Fatal("couldn't parse file: ", err)
		}

		messageFile, err := os.Create(dialectDir + "message.go")
		if err != nil {
			log.Fatal("couldn't open output: ", err)
		}
		defer messageFile.Close()

		messageFile.Write([]byte(generatedHeader))

		var buffer bytes.Buffer
		if err := t.Execute(&buffer, data); err != nil {
			log.Fatal("couldn't execute template for message.go: ", err)
		}
		formatted, err := format.Source(buffer.Bytes())
		if err != nil {
			log.Fatal("couldn't format generated message.go: ", err)
			messageFile.Write(buffer.Bytes())
		}else{
			messageFile.Write(formatted)
		}
		buffer.Reset()

		t, err = template.New("dialect").Parse(dialectTemplate())

		if err != nil {
			log.Fatal("couldn't parse file: ", err)
		}

		dialectFile, err := os.Create(dialectDir + "dialect.go")
		if err != nil {
			log.Fatal("couldn't open output: ", err)
		}
		defer dialectFile.Close()

		dialectFile.Write([]byte(generatedHeader))

		if err := t.Execute(&buffer, data); err != nil {
			log.Fatal("couldn't execute template for dialect.go: ", err)
		}
		formatted, err = format.Source(buffer.Bytes())
		if err != nil {
			log.Fatal("couldn't format generated dialect.go: ", err)
			dialectFile.Write(buffer.Bytes())
		}else{
			dialectFile.Write(formatted)
		}
		buffer.Reset()

		versionFile, err := os.Create(dialectDir + "version.go")
		if err != nil {
			log.Fatal("couldn't open output: ", err)
		}
		defer versionFile.Close()

		formatted, err = format.Source([]byte(generatedHeader + "package mavlink\n\nconst (\n\tVersion = \"" + *version + "\"\n\tMavlinkVersion = " + strconv.Itoa(*mavlinkVersion) + "\n)\n"))
		if err != nil {
			log.Fatal("couldn't format generated version.go: ", err)
			versionFile.Write(buffer.Bytes())
		}else{
			versionFile.Write(formatted)
		}
	}
}

// helper to remove the extension from the base name
func baseName(s string) string {
	return strings.TrimSuffix(filepath.Base(s), filepath.Ext(s))
}

func findOutFile() string {
	if *outfile == "" {
		*outfile = strings.ToLower(baseName(*infile)) + ".go"
	}

	dir, err := os.Getwd()
	if err != nil {
		log.Fatal("Getwd(): ", err)
	}

	return filepath.Join(dir, strings.ToLower(*outfile))
}
