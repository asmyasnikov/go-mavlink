/*
 * CODE GENERATED AUTOMATICALLY WITH
 *    github.com/wlbr/templify
 * THIS FILE SHOULD NOT BE EDITED BY HAND
 */

package main

// messageTemplate is a generated function returning the template as a string.
// That string should be parsed by the functions of the golang's template package.
func messageTemplate() string {
	var tmpl = "// Code generated by go-mavlink/mavgen\n" +
		"// DO NOT EDIT!\n" +
		"\n" +
		"package mavlink\n" +
		"\n" +
		"import (\n" +
		"\t\"errors\"\n" +
		"\t\"github.com/asmyasnikov/go-mavlink/x25\"\n" +
		"\t\"sync\"\n" +
		"\t\"time\"\n" +
		")\n" +
		"\n" +
		"const (\n" +
		"\tmagicNumber = {{if .Mavlink2 -}} 0xfd {{- else -}} 0xfe {{- end}}\n" +
		")\n" +
		"\n" +
		"type MAVLINK_PARSE_STATE int\n" +
		"\n" +
		"// MAVLINK_PARSE_STATES\n" +
		"const (\n" +
		"\tMAVLINK_PARSE_STATE_UNINIT             MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_IDLE               MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_STX            MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_LENGTH         MAVLINK_PARSE_STATE = iota\n" +
		"{{- if .Mavlink2}}\n" +
		"\tMAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS   MAVLINK_PARSE_STATE = iota\n" +
		"{{- end}}\n" +
		"\tMAVLINK_PARSE_STATE_GOT_SEQ            MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_SYSID          MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_COMPID         MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_MSGID1         MAVLINK_PARSE_STATE = iota\n" +
		"{{- if .Mavlink2}}\n" +
		"\tMAVLINK_PARSE_STATE_GOT_MSGID2         MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_MSGID3         MAVLINK_PARSE_STATE = iota\n" +
		"{{- end}}\n" +
		"\tMAVLINK_PARSE_STATE_GOT_PAYLOAD        MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_CRC1           MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_BAD_CRC        MAVLINK_PARSE_STATE = iota\n" +
		"\tMAVLINK_PARSE_STATE_GOT_GOOD_MESSAGE   MAVLINK_PARSE_STATE = iota\n" +
		")\n" +
		"\n" +
		"var (\n" +
		"\t// ErrUnknownMsgID define\n" +
		"\tErrUnknownMsgID = errors.New(\"unknown msg id\")\n" +
		"\t// ErrCrcFail define\n" +
		"\tErrCrcFail = errors.New(\"checksum did not match\")\n" +
		"\t// ErrNoNewData define\n" +
		"\tErrNoNewData = errors.New(\"No new data\")\n" +
		"\t// currentSeqNum\n" +
		"\tcurrentSeqNum uint8 = 0\n" +
		"\t// dialects\n" +
		"\tdialects DialectSlice = DialectSlice{ {{- .DialectName -}} }\n" +
		")\n" +
		"\n" +
		"func AddDialect(d *Dialect) {\n" +
		"\tdialects.Add(d)\n" +
		"}\n" +
		"\n" +
		"func RemoveDialect(d *Dialect) {\n" +
		"\tdialects.Remove(d)\n" +
		"}\n" +
		"\n" +
		"// MessageID typedef\n" +
		"type MessageID {{if .Mavlink2 -}} uint32 {{else}} uint8 {{- end}}\n" +
		"\n" +
		"// Message is a basic type for encoding/decoding mavlink messages.\n" +
		"// use the Pack() and Unpack() routines on specific message\n" +
		"// types to convert them to/from the Packet type.\n" +
		"type Message interface {\n" +
		"\tPack(*Packet) error\n" +
		"\tUnpack(*Packet) error\n" +
		"\tMsgID() MessageID\n" +
		"\tMsgName() string\n" +
		"}\n" +
		"\n" +
		"// Packet is a wire type for encoding/decoding mavlink messages.\n" +
		"// use the ToPacket() and FromPacket() routines on specific message\n" +
		"// types to convert them to/from the Message type.\n" +
		"type Packet struct {\n" +
		"{{- if .Mavlink2}}\n" +
		"\tInCompatFlags uint8     // incompat flags\n" +
		"\tCompatFlags   uint8     // compat flags\n" +
		"{{- end}}\n" +
		"\tSeqID         uint8     // Sequence of packet\n" +
		"\tSysID         uint8     // ID of message sender system/aircraft\n" +
		"\tCompID        uint8     // ID of the message sender component\n" +
		"\tMsgID         MessageID // ID of message in payload\n" +
		"\tPayload       []byte\n" +
		"\tChecksum      uint16\n" +
		"}\n" +
		"\n" +
		"func (p *Packet) nextSeqNum() byte {\n" +
		"\tcurrentSeqNum++\n" +
		"\treturn currentSeqNum\n" +
		"}\n" +
		"\n" +
		"func (p *Packet) Encode(sysID, compID uint8, m Message) error {\n" +
		"\tp.SeqID = p.nextSeqNum()\n" +
		"\tp.SysID = sysID\n" +
		"\tp.CompID = compID\n" +
		"\tif err := m.Pack(p); err != nil {\n" +
		"\t\treturn err\n" +
		"\t}\n" +
		"\tif err := p.fixChecksum(dialects); err != nil {\n" +
		"\t\treturn err\n" +
		"\t}\n" +
		"\treturn nil\n" +
		"}\n" +
		"\n" +
		"func (p *Packet) Bytes() []byte {\n" +
		"\tbytes := []byte{\n" +
		"\t    magicNumber,\n" +
		"\t    byte(len(p.Payload)),\n" +
		"{{- if .Mavlink2}}\n" +
		"\t    uint8(p.InCompatFlags),\n" +
		"\t    uint8(p.CompatFlags),\n" +
		"{{- end}}\n" +
		"\t    p.SeqID,\n" +
		"\t    p.SysID,\n" +
		"\t    p.CompID,\n" +
		"\t    uint8(p.MsgID),\n" +
		"{{- if .Mavlink2}}\n" +
		"\t    uint8(p.MsgID >> 8),\n" +
		"\t    uint8(p.MsgID >> 16),\n" +
		"{{- end}}\n" +
		"    } // header\n" +
		"\tbytes = append(bytes, p.Payload...)\n" +
		"\tbytes = append(bytes, u16ToBytes(p.Checksum)...)\n" +
		"\treturn bytes\n" +
		"}\n" +
		"\n" +
		"type Multiplexer struct {\n" +
		"\tsync.Mutex\n" +
		"\tlisteners\tmap[chan []byte]bool\n" +
		"}\n" +
		"\n" +
		"func NewMultiplexer() Multiplexer {\n" +
		"\tm := Multiplexer{\n" +
		"\t\tlisteners: make(map[chan []byte]bool),\n" +
		"\t}\n" +
		"\treturn m\n" +
		"}\n" +
		"\n" +
		"// Decoder struct provide decoding processor\n" +
		"type Decoder struct {\n" +
		"\tmultiplexer Multiplexer\n" +
		"\tdata      chan []byte\n" +
		"\tdecoded\t  chan *Packet\n" +
		"}\n" +
		"\n" +
		"func (m *Multiplexer) register() chan []byte {\n" +
		"\tdata := make(chan []byte)\n" +
		"\tm.Lock()\n" +
		"\tm.listeners[data] = true\n" +
		"\tm.Unlock()\n" +
		"\treturn data\n" +
		"}\n" +
		"\n" +
		"func (m *Multiplexer) notify(buffer []byte) {\n" +
		"\tm.Lock()\n" +
		"\tfor k, _ := range m.listeners {\n" +
		"\t\tk <- buffer\n" +
		"\t}\n" +
		"\tm.Unlock()\n" +
		"}\n" +
		"\n" +
		"func (m *Multiplexer) clear(data chan []byte) {\n" +
		"\tm.Lock()\n" +
		"\tdelete(m.listeners, data)\n" +
		"\tm.Unlock()\n" +
		"}\n" +
		"\n" +
		"type Parser struct {\n" +
		"\tstate  MAVLINK_PARSE_STATE\n" +
		"\tpacket Packet\n" +
		"\tcrc    *x25.X25\n" +
		"}\n" +
		"\n" +
		"func (parser *Parser) parseChar(c byte) (*Packet, error) {\n" +
		"\tswitch parser.state {\n" +
		"\tcase MAVLINK_PARSE_STATE_UNINIT,\n" +
		"\t\t MAVLINK_PARSE_STATE_IDLE,\n" +
		"\t\t MAVLINK_PARSE_STATE_GOT_BAD_CRC,\n" +
		"\t\t MAVLINK_PARSE_STATE_GOT_GOOD_MESSAGE :\n" +
		"\t\tif c == magicNumber {\n" +
		"\t\t\tparser.crc = x25.New()\n" +
		"\t\t\tparser.state = MAVLINK_PARSE_STATE_GOT_STX\n" +
		"\t\t}\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_STX:\n" +
		"\t\tparser.packet.Payload = make([]byte, 0, c)\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_LENGTH\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_LENGTH:\n" +
		"{{- if .Mavlink2}}\n" +
		"\t\tparser.packet.InCompatFlags = c\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS:\n" +
		"\t\tparser.packet.CompatFlags = c\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS:\n" +
		"{{- end}}\n" +
		"\t\tparser.packet.SeqID = c\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_SEQ\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_SEQ:\n" +
		"\t\tparser.packet.SysID = c\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_SYSID\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_SYSID:\n" +
		"\t\tparser.packet.CompID = c\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_COMPID\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_COMPID:\n" +
		"\t\tparser.packet.MsgID = MessageID(c)\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_MSGID1\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_MSGID1:\n" +
		"{{- if .Mavlink2}}\n" +
		"\t\tparser.packet.MsgID += MessageID(c << 8)\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_MSGID2\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_MSGID2:\n" +
		"\t\tparser.packet.MsgID += MessageID(c << 8 * 2)\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tparser.state = MAVLINK_PARSE_STATE_GOT_MSGID3\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_MSGID3:\n" +
		"{{- end}}\n" +
		"\t\tparser.packet.Payload = append(parser.packet.Payload, c)\n" +
		"\t\tparser.crc.WriteByte(c)\n" +
		"\t\tif len(parser.packet.Payload) == cap(parser.packet.Payload) {\n" +
		"\t\t\tparser.state = MAVLINK_PARSE_STATE_GOT_PAYLOAD\n" +
		"\t\t}\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_PAYLOAD:\n" +
		"\t\tcrcExtra, err := dialects.findCrcX(parser.packet.MsgID)\n" +
		"\t\tif err != nil {\n" +
		"\t\t\tcrcExtra = 0\n" +
		"\t\t}\n" +
		"\t\tparser.crc.WriteByte(crcExtra)\n" +
		"\t\tif c != uint8(parser.crc.Sum16()&0xFF) {\n" +
		"\t\t\tparser.state = MAVLINK_PARSE_STATE_GOT_BAD_CRC\n" +
		"\t\t\tparser.packet = Packet{}\n" +
		"\t\t\treturn nil, ErrCrcFail\n" +
		"\t\t} else {\n" +
		"\t\t\tparser.state = MAVLINK_PARSE_STATE_GOT_CRC1\n" +
		"\t\t}\n" +
		"\tcase MAVLINK_PARSE_STATE_GOT_CRC1:\n" +
		"\t\tif c == uint8(parser.crc.Sum16()>>8) {\n" +
		"\t\t\tparser.packet.Checksum = parser.crc.Sum16()\n" +
		"\t\t\tparser.state = MAVLINK_PARSE_STATE_GOT_GOOD_MESSAGE\n" +
		"\t\t\tresult := parser.packet\n" +
		"\t\t\tparser.packet = Packet{}\n" +
		"\t\t\treturn &result, nil\n" +
		"\t\t} else {\n" +
		"\t\t\tparser.state = MAVLINK_PARSE_STATE_GOT_BAD_CRC\n" +
		"\t\t\tparser.packet = Packet{}\n" +
		"\t\t\treturn nil, ErrCrcFail\n" +
		"\t\t}\n" +
		"\t}\n" +
		"\treturn nil, nil\n" +
		"}\n" +
		"\n" +
		"func (d *Decoder) PushData(data []byte) {\n" +
		"\td.data <- data\n" +
		"}\n" +
		"\n" +
		"func (d *Decoder) NextPacket(duration time.Duration) *Packet {\n" +
		"\tselect {\n" +
		"\tcase packet := <- d.decoded :\n" +
		"\t\treturn packet\n" +
		"\tcase <-time.After(duration) :\n" +
		"\t\treturn nil\n" +
		"\t}\n" +
		"}\n" +
		"\n" +
		"// NewChannelDecoder function create decoder instance with default dialect\n" +
		"func NewChannelDecoder() *Decoder {\n" +
		"\td := &Decoder{\n" +
		"\t\tmultiplexer: NewMultiplexer(),\n" +
		"\t\tdata:        make(chan []byte, 256),\n" +
		"\t\tdecoded:     make(chan *Packet),\n" +
		"\t}\n" +
		"\tgo func(){\n" +
		"\t\tfor {\n" +
		"\t\t\tbuffer := <- d.data\n" +
		"\t\t\td.multiplexer.notify(buffer)\n" +
		"\t\t\tfor i, c := range buffer {\n" +
		"\t\t\t\tif c == magicNumber {\n" +
		"\t\t\t\t\tnewBytes := d.multiplexer.register()\n" +
		"\t\t\t\t\tgo func() {\n" +
		"\t\t\t\t\t\tdefer d.multiplexer.clear(newBytes)\n" +
		"\t\t\t\t\t\tvar parser Parser\n" +
		"\t\t\t\t\t\tfor {\n" +
		"\t\t\t\t\t\t\tbuffer := <- newBytes\n" +
		"\t\t\t\t\t\t\tfor _, c := range buffer {\n" +
		"\t\t\t\t\t\t\t\tpacket, err := parser.parseChar(c)\n" +
		"\t\t\t\t\t\t\t\tif err != nil {\n" +
		"\t\t\t\t\t\t\t\t\treturn\n" +
		"\t\t\t\t\t\t\t\t} else if packet != nil {\n" +
		"\t\t\t\t\t\t\t\t\td.decoded <- packet\n" +
		"\t\t\t\t\t\t\t\t\treturn\n" +
		"\t\t\t\t\t\t\t\t}\n" +
		"\t\t\t\t\t\t\t}\n" +
		"\t\t\t\t\t\t}\n" +
		"\t\t\t\t\t}()\n" +
		"\t\t\t\t\tnewBytes <- buffer[i:]\n" +
		"\t\t\t\t}\n" +
		"\t\t\t}\n" +
		"\t\t}\n" +
		"\t}()\n" +
		"\treturn d\n" +
		"}\n" +
		"\n" +
		"func (p *Packet) fixChecksum(dialects DialectSlice) error {\n" +
		"\tcrc := x25.New()\n" +
		"\tcrc.WriteByte(byte(len(p.Payload)))\n" +
		"{{- if .Mavlink2}}\n" +
		"\tcrc.WriteByte(p.InCompatFlags)\n" +
		"\tcrc.WriteByte(p.CompatFlags)\n" +
		"{{- end}}\n" +
		"\tcrc.WriteByte(p.SeqID)\n" +
		"\tcrc.WriteByte(p.SysID)\n" +
		"\tcrc.WriteByte(p.CompID)\n" +
		"\tcrc.WriteByte(byte(p.MsgID >> 0 ))\n" +
		"{{- if .Mavlink2}}\n" +
		"\tcrc.WriteByte(byte(p.MsgID >> 8 ))\n" +
		"\tcrc.WriteByte(byte(p.MsgID >> 16))\n" +
		"{{- end}}\n" +
		"\tcrc.Write(p.Payload)\n" +
		"\tcrcx, err := dialects.findCrcX(p.MsgID)\n" +
		"\tif err != nil {\n" +
		"\t\treturn err\n" +
		"\t}\n" +
		"\tcrc.WriteByte(crcx)\n" +
		"\tp.Checksum = crc.Sum16()\n" +
		"\treturn nil\n" +
		"}\n" +
		"\n" +
		"func u16ToBytes(v uint16) []byte {\n" +
		"\treturn []byte{byte(v & 0xff), byte(v >> 8)}\n" +
		"}\n" +
		""
	return tmpl
}
