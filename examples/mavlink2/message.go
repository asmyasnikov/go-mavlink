// Code generated by go-mavlink/mavgen
// DO NOT EDIT!

package mavlink

import (
	"errors"
	"fmt"
	"github.com/asmyasnikov/go-mavlink/x25"
	"io"
	"runtime"
	"sync"
	"time"
)

const (
	numChecksumBytes = 2
	magicNumber      = 0xfd
	hdrLen           = 10
)

const (
	DECODE_ITERATION_EXIT_CODE_MAGIC_NO_FOUND = iota
	DECODE_ITERATION_EXIT_CODE_TOO_SMALL = iota
	DECODE_ITERATION_EXIT_CODE_SMALL_BUFFER = iota
	DECODE_ITERATION_EXIT_ENUM_END = iota
)

var (
	// ErrUnknownMsgID define
	ErrUnknownMsgID = errors.New("unknown msg id")
	// ErrCrcFail define
	ErrCrcFail = errors.New("checksum did not match")
)

// MessageID typedef
type MessageID uint32

// Message is a basic type for encoding/decoding mavlink messages.
// use the Pack() and Unpack() routines on specific message
// types to convert them to/from the Packet type.
type Message interface {
	Pack(*Packet) error
	Unpack(*Packet) error
	MsgID() MessageID
	MsgName() string
}

// Packet is a wire type for encoding/decoding mavlink messages.
// use the ToPacket() and FromPacket() routines on specific message
// types to convert them to/from the Message type.
type Packet struct {
	InCompatFlags uint8     // incompat flags
	CompatFlags   uint8     // compat flags
	SeqID         uint8     // Sequence of packet
	SysID         uint8     // ID of message sender system/aircraft
	CompID        uint8     // ID of the message sender component
	MsgID         MessageID // ID of message in payload
	Payload       []byte
	Checksum      uint16
}

// Decoder struct provide decoding processor
type Decoder struct {
	sync.Mutex
	CurrSeqID uint8        // last seq id decoded
	Dialects  DialectSlice // dialects that can be decoded
	data   	  chan []byte
	buffer    []byte // stores bytes we've read from br
}

// Encoder struct provide encoding processor
type Encoder struct {
	sync.Mutex
	CurrSeqID uint8        // last seq id encoded
	Dialects  DialectSlice // dialects that can be encoded
	data   	  chan []byte
}

// NewChannelDecoder function create decoder instance with default dialect
func NewChannelDecoder(data chan []byte) *Decoder {
	d := &Decoder{
		Dialects: DialectSlice{DialectCommon},
		data 	: data,
	}
	return d
}

// NewDecoder function create decoder instance with default dialect
func NewDecoder(r io.Reader) *Decoder {
	d := &Decoder{
		Dialects: DialectSlice{DialectCommon},
		data	: make(chan []byte, 256),
	}
	go func (){
		for {
			bytesRead := make([]byte, 256)
			n, err := io.ReadAtLeast(r, bytesRead, 1)
			if err != nil {
				runtime.Gosched()
			} else {
				fmt.Println("Receive decoder data : ", bytesRead[:n])
				d.data <- bytesRead[:n]
				fmt.Println("Decoder data pushed: ", bytesRead[:n])
			}
		}
	}()
	return d
}

// NewEncoder function create encoder instance with default dialect
func NewChannelEncoder(data chan []byte) *Encoder {
	e := &Encoder{
		Dialects: DialectSlice{DialectCommon},
		data	: data,
	}
	return e
}

// NewEncoder function create encoder instance with default dialect
func NewEncoder(w io.Writer) *Encoder {
	e := &Encoder{
		Dialects: DialectSlice{DialectCommon},
		data	: make(chan []byte, 256),
	}
	go func (){
		for {
			buffer := <- e.data
			fmt.Println("Receive encoder data : ", buffer)
			w.Write(buffer)
		}
	}()
	return e
}

// helper to create packet w/header populated with received bytes
func newPacketFromBytes(b []byte) (*Packet, int) {
	return &Packet{
		InCompatFlags: b[1],
		CompatFlags:   b[2],
		SeqID:         b[3],
		SysID:         b[4],
		CompID:        b[5],
		MsgID:         MessageID(b[6] + (b[7] << 8) + (b[8] << 16)),
	}, int(b[0])
}

// Decode function reads and parses from its reader
// Typically, the caller will check the p.MsgID to see if it's
// a message they're interested in, and convert it to the
// corresponding type via Message.FromPacket()
func (dec *Decoder) Decode() (*Packet, error) {
	return dec.TimedDecode(nil)
}

// Decode function reads and parses from its reader
// Typically, the caller will check the p.MsgID to see if it's
// a message they're interested in, and convert it to the
// corresponding type via Message.FromPacket()
func (dec *Decoder) TimedDecode(duration *time.Duration) (*Packet, error) {
	started := time.Now()
	iterationExitCode := DECODE_ITERATION_EXIT_ENUM_END
	for {
		select {
			case buffer := <- dec.data:
				fmt.Println("Receive new data from channel...")
				dec.buffer = append(dec.buffer, buffer...)
			case <-time.After(time.Microsecond) :
				fmt.Println("Timeout data from channel...")
				if iterationExitCode != DECODE_ITERATION_EXIT_CODE_MAGIC_NO_FOUND {
					return nil, errors.New("No new data")
				}
		}
		fmt.Printf("Try to find MAGIC in buffer[%d].\n", len(dec.buffer))
		fmt.Println(dec.buffer)
		startFoundInBuffer := false
		// discard bytes in buffer before start byte
		for i, b := range dec.buffer {
			if b == magicNumber {
				dec.buffer = dec.buffer[i:]
				startFoundInBuffer = true
				break
			}
		}

		// if start not found, do next iteration
		if !startFoundInBuffer {
			fmt.Println("Not found MAGIC. Next loop iteration...")
			if len(dec.buffer) > 0 {
				dec.buffer = dec.buffer[len(dec.buffer)-1:]
			}
			iterationExitCode = DECODE_ITERATION_EXIT_CODE_MAGIC_NO_FOUND
			continue
		}
		// if buffer length is too small, do next iteration
		if len(dec.buffer) < 2 {
			fmt.Printf("Len of buffer too small (len = %d bytes). Next loop iteration...\n", len(dec.buffer))
			iterationExitCode = DECODE_ITERATION_EXIT_CODE_TOO_SMALL
			continue
		}

		// buffer[1] is LENGTH and we've already read len(buffer) bytes
		payloadLen := int(dec.buffer[1])
		packetLen := hdrLen + payloadLen + numChecksumBytes
		bytesNeeded := packetLen - len(dec.buffer)

		// if buffer length less then needed message length, do next iteration
		if bytesNeeded > 0 {
			fmt.Printf("Len of buffer too small (need %d bytes)...\n", bytesNeeded)
			if duration != nil && time.Now().Sub(started) > *duration || iterationExitCode == DECODE_ITERATION_EXIT_CODE_SMALL_BUFFER{
				fmt.Println("Wait time elapsed...")
				dec.buffer = dec.buffer[1:]
			}else{
				fmt.Println("Next loop iteration...")
				iterationExitCode = DECODE_ITERATION_EXIT_CODE_SMALL_BUFFER
			}
			continue
		}

		// hdr contains LENGTH, SEQ, SYSID, COMPID, MSGID
		// (hdrLen - 1) because we don't include the start byte
		hdr := make([]byte, hdrLen-1)
		// don't include start byte
		hdr = dec.buffer[1:hdrLen]

		p, payloadLen := newPacketFromBytes(hdr)

		crc := x25.New()
		crc.Write(hdr)

		payloadStart := hdrLen
		p.Payload = dec.buffer[payloadStart : payloadStart+payloadLen]
		crc.Write(p.Payload)

		crcx, err := dec.Dialects.findCrcX(p.MsgID)
		if err != nil {
			dec.buffer = dec.buffer[1:]
			// return error here to allow caller to decide if stream is
			// corrupted or if we're getting the wrong dialect
			fmt.Println("Error", err)
			return p, err
		}
		crc.WriteByte(crcx)

		p.Checksum = bytesToU16(dec.buffer[payloadStart+payloadLen : payloadStart+payloadLen+numChecksumBytes])

		// does the transmitted checksum match our computed checksum?
		if p.Checksum != crc.Sum16() {
			// strip off start byte
			dec.buffer = dec.buffer[1:]
			fmt.Println("Bad decode. Sliced...")
		} else {
			dec.CurrSeqID = p.SeqID
			dec.buffer = dec.buffer[packetLen:]
			fmt.Println("Good decode. Sliced...")
			fmt.Println(dec.buffer)
			return p, nil
		}
	}
}

// DecodeBytes function provide decode a packet from a previously received buffer (such as
// a UDP packet), b must contain a complete message
func (dec *Decoder) DecodeBytes(b []byte) (*Packet, error) {
	if len(b) < hdrLen || b[0] != magicNumber {
		return nil, errors.New("invalid header")
	}

	p, payloadLen := newPacketFromBytes(b[1:])

	crc := x25.New()
	p.Payload = b[hdrLen : hdrLen+payloadLen]
	crc.Write(b[1 : hdrLen+payloadLen])

	crcx, err := dec.Dialects.findCrcX(p.MsgID)
	if err != nil {
		return p, err
	}
	crc.WriteByte(crcx)

	p.Checksum = bytesToU16(b[hdrLen+payloadLen:])

	// does the transmitted checksum match our computed checksum?
	if p.Checksum != crc.Sum16() {
		return p, ErrCrcFail
	}

	dec.CurrSeqID = p.SeqID
	return p, nil
}

// Encode function is a helper that accepts a Message, internally converts
// it to a Packet, sets the Packet's SeqID based on the
// and then writes it to its writer via EncodePacket()
func (enc *Encoder) Encode(sysID, compID uint8, m Message) error {
	var p Packet
	if err := m.Pack(&p); err != nil {
		return err
	}

	p.SysID, p.CompID = sysID, compID

	return enc.EncodePacket(&p)
}

// EncodePacket function provide encode writes p to its writer
func (enc *Encoder) EncodePacket(p *Packet) error {

	hdr := []byte{magicNumber, byte(len(p.Payload)), uint8(0), uint8(0), enc.CurrSeqID, p.SysID, p.CompID, uint8(p.MsgID & 0xFF), uint8((p.MsgID >> 8) & 0xFF), uint8((p.MsgID >> 16) & 0xFF)} // header
	enc.data <- hdr

	crc := x25.New()

	crc.Write(hdr[1:]) // don't include start byte

	// payload
	enc.data <- p.Payload

	crc.Write(p.Payload)

	// crc extra
	crcx, err := enc.Dialects.findCrcX(p.MsgID)
	if err != nil {
		return err
	}

	crc.WriteByte(crcx)

	// crc
	crcBytes := u16ToBytes(crc.Sum16())

	enc.data <- crcBytes

	enc.CurrSeqID++

	return err
}

func u16ToBytes(v uint16) []byte {
	return []byte{byte(v & 0xff), byte(v >> 8)}
}

func bytesToU16(p []byte) uint16 {
	// NB: does not check size of p
	return (uint16(p[1]) << 8) | uint16(p[0])
}
