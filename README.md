[<img src="https://travis-ci.org/asmyasnikov/go-mavlink.svg?branch=master">](https://travis-ci.org/asmyasnikov/go-mavlink) [![Go Report Card](https://goreportcard.com/badge/github.com/asmyasnikov/go-mavlink)](https://goreportcard.com/report/github.com/asmyasnikov/go-mavlink)
# go-mavlink

a [Go](http://golang.org/) package for reading/writing [mavlink](http://qgroundcontrol.org/mavlink/start) 1.0 and 2.0 messages.

## installation

* install mavgen tool: `go get github.com/asmyasnikov/go-mavlink/mavgen`
* generate code from mavlink xml definitions: `go generate` or `mavgen -f ardupilotmega.xml -1 -c`

xml definitions can be updated from https://github.com/mavlink/mavlink

## usage

package `go-mavlink/mavgen` is used only for generating classes from mavlink xml definitions, it is not generally intended to be used by anything other than the `go generate` command.

```bash
Usage: mavgen (-1|-2) [-c "github.com/my/project/mavlink/path"] [-p] [-f ./ardupilotmega.xml] [-v "ardupilotmega-v1.2.3"]
  -1    mavlink v1
  -2    mavlink v2
  -c string
        common mavlink package path used for import from go code. For example "github.com/asmyasnikov/go-mavlink/generated/mavlink1"
  -f string
        mavlink xml-definition file input
  -p    generate common mavlink package
  -v string
        custom version of mavlink dialect (default "devel")
```

packages `go-mavlink/generated/mavlink1` and  is the main package used for encoding/decoding mavlink messages.

`mavlink.Packet` is the struct that gets sent over the wire, and `mavlink.Message` is an interface implemented by all mavlink classes generated by `mavgen`. 

### dialects

Several mavlink dialects define messages for overlapping msg ids, so it is required to specify which dialects you'd like to use with default imports.

```go
import (
    mavlink "github.com/asmyasnikov/go-mavlink/generated/mavlink1" // mavlink common package
    _ "github.com/asmyasnikov/go-mavlink/generated/mavlink1/ardupilotmega" // init support ardupilotmega dialect
)
```

Existing dialects (pre-generated) are:
* ardupilotmega
* asluav
* common
* minimal
* matrixpilot
* ualberta

### marshall and unmarshall packet

Marshalling:

```go
var packet Packet // make packet outside this code
bytes, err := mavlink.Marshal(&packet)
if err != nil {
    // catch error on marshal
}
```

Unmarshalling for reliable transport protocol for transfer bytes:

```go
var packet Packet
if err := mavlink.Unmarshal([]byte{0xfe, 0x4, 0x0, 0x0, 0x0, 0xde, 0xf, 0x27, 0x0, 0x0, 0xf4, 0xe2}, &packet); err != nil {
    // catch error on marshal
}
// enjoy packet
```

### decode stream

a typical decode loop might look like:

```go
reader := SomeIoReader() // any io.Reader: UDP, serial port, bytes.Buffer, etc
dec := mavlink.NewDecoder(reader)

var packet mavlink.Packet
for {
    if err := dec.Decode(&packet); err != nil {
        // catch error on decode
    }

    // handle packet types you're interested in...
    // you can two ways to get message from packet
    switch packet.MsgID {
    case common.MSG_ID_PARAM_VALUE:
        var pv mavlink.ParamValue
        if err := pv.Unpack(&packet); err == nil {
            // handle param value
        }
    case common.MSG_ID_HEARTBEAT:
        heartbeat, ok := packet.Message().(*common.Heartbeat)
        if ok {
            // handle param value
        }
    }
}
```

### encode stream

the most convenient way to encode is to use `Encoder.Encode()`:

```go
writer := SomeIoWriter() // any io.Writer: UDP, serial port, bytes.Buffer, etc
enc := mavlink.NewEncoder(writer)

packet := mavlink.Packet{
    SysID: 1,
    CompID: 2
}

if err := packet.Encode(&common.Ping{
    Seq: 12345,
}); err != nil {
    // catch error on encode message to packet
}

if err := enc.Encode(&packet); err != nil {
    // catch error on encode packet to encoder (write to writer)
}
```
